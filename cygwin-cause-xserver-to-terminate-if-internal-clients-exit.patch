[PATCH 2/2] Cygwin/X: Cause the X server to terminate if clipboard or WM internal client threads exit due to an error

Calling FatalError from an internal client thread is a no-no, so these failures
are silent at the moment (in the sense that no pop-up occurs to tell the user
that we are terminating or why).

Also, I'm just noticing I should be using pthread_kill() to ensure the signal
is delivered to the thread which is running the main dispatch loop so that will
exit the select() it may be blocked in and notice that DE_TERMINATE is set.

Signed-off-by: Jon TURNEY <jon.turney@dronecode.org.uk>
---
 hw/xwin/winclipboardthread.c |   17 +++++++++++++++++
 hw/xwin/winmultiwindowwm.c   |   22 +++++++++++++++++++++-
 2 files changed, 38 insertions(+), 1 deletions(-)

diff --git a/hw/xwin/winclipboardthread.c b/hw/xwin/winclipboardthread.c
index fefd408..962d9d6 100644
--- a/hw/xwin/winclipboardthread.c
+++ b/hw/xwin/winclipboardthread.c
@@ -84,6 +84,8 @@ winClipboardErrorHandler (Display *pDisplay, XErrorEvent *pErr);
 static int
 winClipboardIOErrorHandler (Display *pDisplay);
 
+static void
+winClipboardThreadExit(void *arg);
 
 /*
  * Main thread function
@@ -110,6 +112,8 @@ winClipboardProc (void *pvNotUsed)
   char			szDisplay[512];
   int			iSelectError;
 
+  pthread_cleanup_push(&winClipboardThreadExit, NULL);
+
   ErrorF ("winClipboardProc - Hello\n");
 
   /* Do we have Unicode support? */
@@ -434,6 +438,8 @@ winClipboardProc (void *pvNotUsed)
   g_pClipboardDisplay = NULL;
   g_hwndClipboard = NULL;
 
+  pthread_cleanup_pop(0);
+
   return NULL;
 }
 
@@ -475,3 +481,14 @@ winClipboardIOErrorHandler (Display *pDisplay)
   
   return 0;
 }
+
+/*
+ * winClipboardThreadExit - Thread exit handler
+ */
+
+static void
+winClipboardThreadExit(void *arg)
+{
+  /* clipboard thread has exited, stop server as well */
+  kill(getpid(), SIGTERM);
+}
diff --git a/hw/xwin/winmultiwindowwm.c b/hw/xwin/winmultiwindowwm.c
index 0de607d..87cb3dc 100644
--- a/hw/xwin/winmultiwindowwm.c
+++ b/hw/xwin/winmultiwindowwm.c
@@ -180,6 +180,9 @@ winMultiWindowXMsgProcErrorHandler (Display *pDisplay, XErrorEvent *pErr);
 static int
 winMultiWindowXMsgProcIOErrorHandler (Display *pDisplay);
 
+static void
+winMultiWindowThreadExit(void *arg);
+
 static int
 winRedirectErrorHandler (Display *pDisplay, XErrorEvent *pErr);
 
@@ -637,6 +640,8 @@ winMultiWindowWMProc (void *pArg)
 {
   WMProcArgPtr		pProcArg = (WMProcArgPtr)pArg;
   WMInfoPtr		pWMInfo = pProcArg->pWMInfo;
+
+  pthread_cleanup_push(&winMultiWindowThreadExit, NULL);
   
   /* Initialize the Window Manager */
   winInitMultiWindowWM (pWMInfo, pProcArg);
@@ -849,6 +854,9 @@ winMultiWindowWMProc (void *pArg)
 #if CYGMULTIWINDOW_DEBUG
   ErrorF("-winMultiWindowWMProc ()\n");
 #endif
+
+  pthread_cleanup_pop(0);
+
   return NULL;
 }
 
@@ -871,6 +879,8 @@ winMultiWindowXMsgProc (void *pArg)
   int			iReturn;
   XIconSize		*xis;
 
+  pthread_cleanup_push(&winMultiWindowThreadExit, NULL);
+
   ErrorF ("winMultiWindowXMsgProc - Hello\n");
 
   /* Check that argument pointer is not invalid */
@@ -1108,7 +1118,7 @@ winMultiWindowXMsgProc (void *pArg)
     }
 
   XCloseDisplay (pProcArg->pDisplay);
-  pthread_exit (NULL);
+  pthread_cleanup_pop(0);
   return NULL;
 }
 
@@ -1428,6 +1438,16 @@ winMultiWindowXMsgProcIOErrorHandler (Display *pDisplay)
   return 0;
 }
 
+/*
+ * winMultiWindowThreadExit - Thread exit handler
+ */
+
+static void
+winMultiWindowThreadExit(void *arg)
+{
+  /* multiwindow client thread has exited, stop server as well */
+  kill(getpid(), SIGTERM);
+}
 
 /*
  * Catch RedirectError to detect other window manager running
-- 
1.6.4.2

