From 02a5bf6dfbb6aece6aa1e27869426d7031e16b04 Mon Sep 17 00:00:00 2001
From: Jon TURNEY <jon.turney@dronecode.org.uk>
Date: Tue, 7 Jul 2009 20:51:34 +0100
Subject: [PATCH 3/5] Cygwin/X: Unmap minimized windows in rootless modes

At the moment, when a window is minimized, it is moved to (0,0) on the shadow
framebuffer.  This can leads to various problems: tooltips and menus can 'punch
through' from an apparently minimized window if the mouse pointer is positioned
over the native frame of another X window which covers the sensitive regions of
the apparently minimized window.  I think  may also be leading to some repainting
glitches when uncovering areas covered by native window frames.

So, don't move minimized windows to (0,0), simply unmap them.

This has the disadvantage that the contents of windows which are minimized are
no longer stored in the shadow frame buffer, so must be redrawn when restored,
but I assume they were being re-exposed when restored, anyhow...

Signed-off-by: Jon TURNEY <jon.turney@dronecode.org.uk>
---
 hw/xwin/winmultiwindowwindow.c  |   10 +---------
 hw/xwin/winmultiwindowwm.c      |    3 +++
 hw/xwin/winmultiwindowwndproc.c |   29 ++++++++++++++++++++++++++++-
 3 files changed, 32 insertions(+), 10 deletions(-)

diff --git a/hw/xwin/winmultiwindowwindow.c b/hw/xwin/winmultiwindowwindow.c
index 2e46e93..9bc527a 100644
--- a/hw/xwin/winmultiwindowwindow.c
+++ b/hw/xwin/winmultiwindowwindow.c
@@ -296,12 +296,6 @@ winUnmapWindowMultiWindow (WindowPtr pWin)
   WIN_UNWRAP(UnrealizeWindow); 
   fResult = (*pScreen->UnrealizeWindow)(pWin);
   WIN_WRAP(UnrealizeWindow, winUnmapWindowMultiWindow);
-  
-  /* Flag that the window has been killed */
-  pWinPriv->fXKilled = TRUE;
- 
-  /* Destroy the Windows window associated with this X window */
-  winDestroyWindowsWindow (pWin);
 
   return fResult;
 }
@@ -975,9 +969,7 @@ winAdjustXWindow (WindowPtr pWin, HWND hwnd)
        * If the Windows window is minimized, its WindowRect has
        * meaningless values so we don't adjust X window to it.
        */
-      vlist[0] = 0;
-      vlist[1] = 0;
-      return ConfigureWindow (pWin, CWX | CWY, vlist, wClient(pWin));
+      return 0;
     }
   
   pDraw = &pWin->drawable;
diff --git a/hw/xwin/winmultiwindowwm.c b/hw/xwin/winmultiwindowwm.c
index 9724c2e..4b689bf 100644
--- a/hw/xwin/winmultiwindowwm.c
+++ b/hw/xwin/winmultiwindowwm.c
@@ -705,6 +705,9 @@ winMultiWindowWMProc (void *pArg)
 	  UpdateName (pWMInfo, pNode->msg.iWindow);
 	  winUpdateIcon (pNode->msg.iWindow);
 
+	  /* Map the window */
+	  XMapWindow(pWMInfo->pDisplay, pNode->msg.iWindow);
+
 	  break;
 
 	case WM_WM_MAP2:
diff --git a/hw/xwin/winmultiwindowwndproc.c b/hw/xwin/winmultiwindowwndproc.c
index 6b8abef..696c99b 100644
--- a/hw/xwin/winmultiwindowwndproc.c
+++ b/hw/xwin/winmultiwindowwndproc.c
@@ -1019,7 +1019,34 @@ winTopLevelWindowProc (HWND hwnd, UINT message,
 #endif
       /* Adjust the X Window to the moved Windows window */
       winAdjustXWindow (pWin, hwnd);
-      if (wParam == SIZE_MINIMIZED) winReorderWindowsMultiWindow();
+
+      switch (wParam)
+        {
+        case SIZE_MINIMIZED:
+          {
+            wmMsg.msg = WM_WM_UNMAP;
+            /* Tell our Window Manager thread to unmap the window */
+            if (fWMMsgInitialized)
+              winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
+
+            winReorderWindowsMultiWindow();
+
+            break;
+          }
+        case SIZE_RESTORED:
+        case SIZE_MAXIMIZED:
+          {
+            wmMsg.msg = WM_WM_MAP;
+            /* Tell our Window Manager thread to map the window */
+            if (fWMMsgInitialized)
+              winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
+
+            winReorderWindowsMultiWindow();
+
+            break;
+          }
+        }
+
       return 0; /* end of WM_SIZE handler */
 
     case WM_STYLECHANGED:
-- 
1.6.4.2

