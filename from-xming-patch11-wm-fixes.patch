Various internalwm fixes

# Remove frames from 'dock' windows and make them topmost in -multiwindow mode.
# Remove frames from windows with MOTIF_WM_HINTS of no decorations in -multiwindow mode.
# Apply some _NET_WM_STATE hints in -multiwindow mode.
# Now with extra style handling goodness!
# Correctly parent XA_WM_TRANSIENT_FOR windows in -multiwindow mode when a windows window is created.
# Bugzilla 11147, fix a crash in function winMultiWindowGetTransientFor().
# Fix the annoying menu/tooltip 'punch-through' problem in -multiwindow mode.
# Only allow WM_MOUSEWHEEL messages to act on the client area of a focussed window.
# Prevent the mouse wheel from stalling when another window is minimized.
# Notify X when the keyboard focus is lost to a pure Windows window in -multiwindow mode.

Things in xming patch 11 not included here
# Use an internally generated cookie for authentication of server clients when running the -auth option in -multiwindow mode. (separate patch)
# Mouse polling (reduce to 10 mS from 500).
# Change superseded functions GetWindowLong(), SetWindowLong() and RegisterClass().
# Adjust the style of the Windows title in XDMCP mode from 'Xming - hostname' to 'hostname:display-number.screen'. (in tooltip fix patch)


Copyright (C) Colin Harrison 2005-2008
http://www.straightrunning.com/XmingNotes/
http://sourceforge.net/projects/xming/ 

---
 xserver/hw/xwin/winmultiwindowclass.c   |    4 
 xserver/hw/xwin/winmultiwindowwindow.c  |   39 ++++--
 xserver/hw/xwin/winmultiwindowwm.c      |  199 +++++++++++++++++++++++++++++++-
 xserver/hw/xwin/winmultiwindowwndproc.c |  118 +++++++-----------
 xserver/hw/xwin/winwindow.h             |   19 +++
 5 files changed, 294 insertions(+), 85 deletions(-)

Index: xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowclass.c
===================================================================
--- xorg-server-1.5.3.orig/xserver/hw/xwin/winmultiwindowclass.c
+++ xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowclass.c
@@ -1,5 +1,6 @@
 /*
  *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
+ *Copyright (C) Colin Harrison 2005-2008
  *
  *Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -26,6 +27,7 @@
  *from the XFree86 Project.
  *
  * Authors:     Earle F. Philhower, III
+ *              Colin Harrison
  */
 
 #ifdef HAVE_XWIN_CONFIG_H
@@ -263,7 +265,7 @@ winMultiWindowGetTransientFor (WindowPtr
       if (prop->propertyName == XA_WM_TRANSIENT_FOR)
         {
           if (ppDaddy)
-            memcpy (*ppDaddy, prop->data, sizeof (WindowPtr));
+            memcpy (ppDaddy, prop->data, sizeof (WindowPtr));
           return 1;
         }
       else
Index: xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowwindow.c
===================================================================
--- xorg-server-1.5.3.orig/xserver/hw/xwin/winmultiwindowwindow.c
+++ xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowwindow.c
@@ -1,5 +1,6 @@
 /*
  *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
+ *Copyright (C) Colin Harrison 2005-2008
  *
  *Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -28,6 +29,7 @@
  * Authors:	Kensuke Matsuzaki
  *		Earle F. Philhower, III
  *		Harold L Hunt II
+ *              Colin Harrison
  */
 
 #ifdef HAVE_XWIN_CONFIG_H
@@ -486,6 +488,7 @@ winCreateWindowsWindow (WindowPtr pWin)
   int			iWidth;
   int			iHeight;
   HWND			hWnd;
+  HWND			hFore = NULL;
   WNDCLASSEX		wc;
   winWindowPriv(pWin);
   HICON			hIcon;
@@ -496,6 +499,7 @@ winCreateWindowsWindow (WindowPtr pWin)
   static int		s_iWindowID = 0;
   winPrivScreenPtr	pScreenPriv = pWinPriv->pScreenPriv;
   WinXSizeHints         hints;
+  WindowPtr		pDaddy;
 
 #if CYGMULTIWINDOW_DEBUG
   ErrorF ("winCreateWindowsWindow - pWin: %08x\n", pWin);
@@ -504,17 +508,6 @@ winCreateWindowsWindow (WindowPtr pWin)
   iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
   iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
 
-  /* Default positions if none specified */
-  if (!winMultiWindowGetWMNormalHints(pWin, &hints))
-    hints.flags = 0;
-  if ( !(hints.flags & (USPosition|PPosition)) &&
-       !winMultiWindowGetTransientFor (pWin, NULL) &&
-       !pWin->overrideRedirect )
-    {
-      iX = CW_USEDEFAULT;
-      iY = CW_USEDEFAULT;
-    }
-
   iWidth = pWin->drawable.width;
   iHeight = pWin->drawable.height;
 
@@ -570,6 +563,28 @@ winCreateWindowsWindow (WindowPtr pWin)
   wc.lpszClassName = pszClass;
   RegisterClassEx (&wc);
 
+  if (!pWin->overrideRedirect)
+  {
+    if (winMultiWindowGetTransientFor (pWin, &pDaddy))
+    {
+      if (pDaddy)
+      {
+        hFore = GetForegroundWindow();
+        if (hFore && (pDaddy != (WindowPtr)GetProp(hFore, WIN_WID_PROP))) hFore = NULL;
+      }
+    }
+    else
+    {
+      /* Default positions if none specified */
+      if (!winMultiWindowGetWMNormalHints(pWin, &hints)) hints.flags = 0;
+      if (!(hints.flags & (USPosition|PPosition)))
+      {
+        iX = CW_USEDEFAULT;
+        iY = CW_USEDEFAULT;
+      }
+    }
+  }
+
   /* Create the window */
   /* Make it OVERLAPPED in create call since WS_POPUP doesn't support */
   /* CW_USEDEFAULT, change back to popup after creation */
@@ -581,7 +596,7 @@ winCreateWindowsWindow (WindowPtr pWin)
 			  iY,			/* Vertical position */
 			  iWidth,		/* Right edge */ 
 			  iHeight,		/* Bottom edge */
-			  (HWND) NULL,		/* No parent or owner window */
+			  hFore,		/* Null or Parent window if transient*/
 			  (HMENU) NULL,		/* No menu */
 			  GetModuleHandle (NULL), /* Instance handle */
 			  pWin);		/* ScreenPrivates */
Index: xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowwm.c
===================================================================
--- xorg-server-1.5.3.orig/xserver/hw/xwin/winmultiwindowwm.c
+++ xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowwm.c
@@ -1,5 +1,6 @@
 /*
  *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
+ *Copyright (C) Colin Harrison 2005-2008
  *
  *Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -26,6 +27,7 @@
  *from the XFree86 Project.
  *
  * Authors:	Kensuke Matsuzaki
+ *              Colin Harrison
  */
 
 /* X headers */
@@ -58,11 +60,16 @@
 #include "objbase.h"
 #include "ddraw.h"
 #include "winwindow.h"
+#include "winprefs.h"
+#include "window.h"
+#include "windowstr.h"
 #ifdef XWIN_MULTIWINDOWEXTWM
 #include "windowswmstr.h"
 #endif
 
 extern void winDebug(const char *format, ...);
+extern void winReshapeMultiWindow(WindowPtr pWin);
+extern void winUpdateRgnMultiWindow(WindowPtr pWin);
 
 #ifndef CYGDEBUG
 #define CYGDEBUG NO
@@ -184,6 +191,11 @@ PreserveWin32Stack(WMInfoPtr pWMInfo, Wi
 static Bool
 CheckAnotherWindowManager (Display *pDisplay, DWORD dwScreen);
 
+static void
+winApplyHints (Display *pDisplay, Window iWindow, HWND hWnd, HWND *zstyle);
+
+void
+winUpdateWindowPosition (HWND hWnd, Bool reshape, HWND *zstyle);
 
 /*
  * Local globals
@@ -698,10 +710,25 @@ winMultiWindowWMProc (void *pArg)
 			   1);
 	  UpdateName (pWMInfo, pNode->msg.iWindow);
 	  winUpdateIcon (pNode->msg.iWindow);
-#if 0
-	  /* Handles the case where there are AOT windows above it in W32 */
-	  PreserveWin32Stack (pWMInfo, pNode->msg.iWindow, GW_HWNDPREV);
+	  {
+	    HWND zstyle = HWND_NOTOPMOST;
+	    winApplyHints (pWMInfo->pDisplay, pNode->msg.iWindow, pNode->msg.hwndWindow, &zstyle);
+	    winUpdateWindowPosition (pNode->msg.hwndWindow, TRUE, &zstyle);
+	  }
+	  break;
+
+	case WM_WM_MAP2:
+#if CYGMULTIWINDOW_DEBUG
+	  ErrorF ("\tWM_WM_MAP2\n");
 #endif
+	  XChangeProperty (pWMInfo->pDisplay,
+			   pNode->msg.iWindow,
+			   pWMInfo->atmPrivMap,
+			   XA_INTEGER,//pWMInfo->atmPrivMap,
+			   32,
+			   PropModeReplace,
+			   (unsigned char *) &(pNode->msg.hwndWindow),
+			   1);
 	  break;
 
 	case WM_WM_UNMAP:
@@ -796,6 +823,7 @@ winMultiWindowWMProc (void *pArg)
 #if CYGMULTIWINDOW_DEBUG
   ErrorF("-winMultiWindowWMProc ()\n");
 #endif
+  return NULL;
 }
 
 
@@ -1056,6 +1084,7 @@ winMultiWindowXMsgProc (void *pArg)
 
   XCloseDisplay (pProcArg->pDisplay);
   pthread_exit (NULL);
+  return NULL;
  
 }
 
@@ -1356,7 +1385,9 @@ winMultiWindowXMsgProcErrorHandler (Disp
 		 pErr->error_code,
 		 pszErrorMsg,
 		 sizeof (pszErrorMsg));
+#if CYGMULTIWINDOW_DEBUG
   ErrorF ("winMultiWindowXMsgProcErrorHandler - ERROR: %s\n", pszErrorMsg);
+#endif
   
   return 0;
 }
@@ -1430,3 +1461,165 @@ winDeinitMultiWindowWM ()
   ErrorF ("winDeinitMultiWindowWM - Noting shutdown in progress\n");
   g_shutdown = TRUE;
 }
+
+/* Windows window styles */
+#define HINT_NOFRAME	(1l<<0)
+#define HINT_BORDER	(1L<<1)
+#define HINT_SIZEBOX	(1l<<2)
+#define HINT_CAPTION	(1l<<3)
+/* These two are used on their own */
+#define HINT_MAX	(1L<<0)
+#define HINT_MIN	(1L<<1)
+
+static void
+winApplyHints (Display *pDisplay, Window iWindow, HWND hWnd, HWND *zstyle)
+{
+  static Atom	windowState, motif_wm_hints, windowType;
+  Atom		type, *pAtom = NULL;
+  int 		format;
+  unsigned long	hint = 0, maxmin = 0, rcStyle, nitems = 0 , left = 0;
+  WindowPtr	pWin = GetProp (hWnd, WIN_WINDOW_PROP);
+
+  if (!hWnd) return;
+  if (!IsWindow (hWnd)) return;
+
+  if (windowState == None) windowState = XInternAtom(pDisplay, "_NET_WM_STATE", False);
+  if (motif_wm_hints == None) motif_wm_hints = XInternAtom(pDisplay, "_MOTIF_WM_HINTS", False);
+  if (windowType == None) windowType = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE", False);
+
+  if (XGetWindowProperty(pDisplay, iWindow, windowState, 0L,
+			 1L, False, XA_ATOM, &type, &format,
+			 &nitems, &left, (unsigned char **)&pAtom) == Success)
+  {
+    if (pAtom && nitems == 1)
+    {
+      static Atom hiddenState, fullscreenState, belowState, aboveState;
+      if (hiddenState == None) hiddenState = XInternAtom(pDisplay, "_NET_WM_STATE_HIDDEN", False);
+      if (fullscreenState == None) fullscreenState = XInternAtom(pDisplay, "_NET_WM_STATE_FULLSCREEN", False);
+      if (belowState == None) belowState = XInternAtom(pDisplay, "_NET_WM_STATE_BELOW", False);
+      if (aboveState == None) aboveState = XInternAtom(pDisplay, "_NET_WM_STATE_ABOVE", False);
+      if (*pAtom == hiddenState) maxmin |= HINT_MIN;
+      else if (*pAtom == fullscreenState) maxmin |= HINT_MAX;
+      if (*pAtom == belowState) *zstyle = HWND_BOTTOM;
+      else if (*pAtom == aboveState) *zstyle = HWND_TOPMOST;
+    }
+    if (pAtom) XFree(pAtom);
+  }
+
+  nitems = left = 0;
+  MwmHints *mwm_hint = NULL;
+  if (XGetWindowProperty(pDisplay, iWindow, motif_wm_hints, 0L,
+			 PropMwmHintsElements, False, motif_wm_hints, &type, &format,
+			 &nitems, &left, (unsigned char **)&mwm_hint) == Success)
+  {
+    if (mwm_hint && nitems == PropMwmHintsElements && (mwm_hint->flags & MwmHintsDecorations))
+    {
+      if (!mwm_hint->decorations) hint |= HINT_NOFRAME;
+      else if (!(mwm_hint->decorations & MwmDecorAll))
+      {
+	if (mwm_hint->decorations & MwmDecorBorder) hint |= HINT_BORDER;
+	if (mwm_hint->decorations & MwmDecorHandle) hint |= HINT_SIZEBOX;
+	if (mwm_hint->decorations & MwmDecorTitle) hint |= HINT_CAPTION;
+      }
+    }
+    if (mwm_hint) XFree(mwm_hint);
+  }
+
+  nitems = left = 0;
+  pAtom = NULL;
+  if (XGetWindowProperty(pDisplay, iWindow, windowType, 0L,
+			 1L, False, XA_ATOM, &type, &format,
+			 &nitems, &left, (unsigned char **)&pAtom) == Success)
+  {
+    if (pAtom && nitems == 1)
+    {
+      static Atom dockWindow;
+      if (dockWindow == None) dockWindow = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE_DOCK", False);
+      if (*pAtom == dockWindow)
+      {
+	hint = (hint & ~HINT_NOFRAME) | HINT_SIZEBOX; /* Xming puts a sizebox on dock windows */
+	*zstyle = HWND_TOPMOST;
+      }
+    }
+    if (pAtom) XFree(pAtom);
+  }
+
+  /* Apply Styles, overriding hint settings from above */
+  rcStyle = winOverrideStyle((unsigned long)pWin);
+  if (rcStyle & STYLE_TOPMOST) *zstyle = HWND_TOPMOST;
+  else if (rcStyle & STYLE_MAXIMIZE) maxmin = (hint & ~HINT_MIN) | HINT_MAX;
+  else if (rcStyle & STYLE_MINIMIZE) maxmin = (hint & ~HINT_MAX) | HINT_MIN;
+  else if (rcStyle & STYLE_BOTTOM) *zstyle = HWND_BOTTOM;
+
+  if (maxmin & HINT_MAX) SendMessage(hWnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
+  else if (maxmin & HINT_MIN) SendMessage(hWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);
+
+  if (rcStyle & STYLE_NOTITLE)
+	hint = (hint & ~HINT_NOFRAME & ~HINT_BORDER & ~HINT_CAPTION) | HINT_SIZEBOX;
+  else if (rcStyle & STYLE_OUTLINE)
+	hint = (hint & ~HINT_NOFRAME & ~HINT_SIZEBOX & ~HINT_CAPTION) | HINT_BORDER;
+  else if (rcStyle & STYLE_NOFRAME)
+	hint = (hint & ~HINT_BORDER & ~HINT_CAPTION & ~HINT_SIZEBOX) | HINT_NOFRAME;
+
+  SetWindowLongPtr (hWnd, GWL_STYLE, GetWindowLongPtr(hWnd, GWL_STYLE) & ~WS_CAPTION & ~WS_SIZEBOX); /* Just in case */
+  if (!hint) /* All on, but no resize of children is allowed */
+    SetWindowLongPtr (hWnd, GWL_STYLE, GetWindowLongPtr(hWnd, GWL_STYLE) | WS_CAPTION | (GetParent(hWnd) ? 0 : WS_SIZEBOX));
+  else if (hint & HINT_NOFRAME); /* All off, so do nothing */
+  else  SetWindowLongPtr (hWnd, GWL_STYLE, GetWindowLongPtr(hWnd, GWL_STYLE) |
+			((hint & HINT_BORDER) ? WS_BORDER : 0) |
+			((hint & HINT_SIZEBOX) ? (GetParent(hWnd) ? 0 : WS_SIZEBOX) : 0) |
+			((hint & HINT_CAPTION) ? WS_CAPTION : 0));
+
+  return;
+}
+
+void
+winUpdateWindowPosition (HWND hWnd, Bool reshape, HWND *zstyle)
+{
+  int	iDx, iDy;
+  RECT	rcNew;
+  WindowPtr	pWin = GetProp (hWnd, WIN_WINDOW_PROP);
+  DrawablePtr	pDraw = NULL;
+
+  if (!pWin) return;
+  pDraw = &pWin->drawable;
+  if (!pDraw) return;
+
+  /* Setup a rectangle with the X window position and size */
+  SetRect (&rcNew, pDraw->x, pDraw->y, pDraw->x + pDraw->width, pDraw->y + pDraw->height);
+
+#if 0
+  ErrorF ("winUpdateWindowPosition - (%d, %d)-(%d, %d)\n",
+	  rcNew.left, rcNew.top,
+	  rcNew.right, rcNew.bottom);
+#endif
+
+  AdjustWindowRectEx (&rcNew, GetWindowLongPtr (hWnd, GWL_STYLE), FALSE, WS_EX_APPWINDOW);
+
+  /* Calculate position deltas */
+  iDx = pDraw->x - rcNew.left;
+  iDy = pDraw->y - rcNew.top;
+
+  /* Calculate new rectangle */
+  rcNew.left += iDx;
+  rcNew.right += iDx;
+  rcNew.top += iDy;
+  rcNew.bottom += iDy;
+
+#if 0
+  ErrorF ("winUpdateWindowPosition - (%d, %d)-(%d, %d)\n",
+	  rcNew.left, rcNew.top,
+	  rcNew.right, rcNew.bottom);
+#endif
+
+  /* Position the Windows window */
+  SetWindowPos (hWnd, *zstyle, rcNew.left, rcNew.top,
+	rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
+	SWP_NOMOVE);
+
+  if (reshape)
+  {
+    winReshapeMultiWindow(pWin);
+    winUpdateRgnMultiWindow(pWin);
+  }
+}
Index: xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowwndproc.c
===================================================================
--- xorg-server-1.5.3.orig/xserver/hw/xwin/winmultiwindowwndproc.c
+++ xorg-server-1.5.3/xserver/hw/xwin/winmultiwindowwndproc.c
@@ -1,5 +1,6 @@
 /*
  *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
+ *Copyright (C) Colin Harrison 2005-2008
  *
  *Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -28,6 +29,7 @@
  * Authors:	Kensuke Matsuzaki
  *		Earle F. Philhower, III
  *		Harold L Hunt II
+ *              Colin Harrison
  */
 
 #ifdef HAVE_XWIN_CONFIG_H
@@ -49,6 +51,8 @@ extern Bool			g_fKeyboardHookLL;
 extern Bool			g_fSoftwareCursor;
 extern Bool			g_fButton[3];
 
+extern void winUpdateWindowPosition (HWND hWnd, Bool reshape, HWND *zstyle);
+
 
 /*
  * Local globals
@@ -403,6 +407,8 @@ winTopLevelWindowProc (HWND hwnd, UINT m
       SetWindowRgn (hwnd, hRgnWindow, TRUE);
       DeleteObject(hRgnWindow);
 
+      SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)XMING_SIGNATURE);
+
       return 0;
 
     case WM_INIT_SYS_MENU:
@@ -646,15 +652,24 @@ winTopLevelWindowProc (HWND hwnd, UINT m
       return winMouseButtonsHandle (s_pScreen, ButtonRelease, HIWORD(wParam) + 5, wParam);
 
     case WM_MOUSEWHEEL:
-      
-      /* Pass the message to the root window */
-      SendMessage (hwndScreen, message, wParam, lParam);
-      return 0;
+      if (SendMessage(hwnd, WM_NCHITTEST, 0, MAKELONG(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))) == HTCLIENT)
+	{
+	  /* Pass the message to the root window */
+	  SendMessage (hwndScreen, message, wParam, lParam);
+	  return 0;
+	}
+      else break;
 
     case WM_SETFOCUS:
       if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
 	break;
 
+      {
+	/* Get the parent window for transient handling */
+	HWND hParent = GetParent(hwnd);
+	if (hParent && IsIconic(hParent)) ShowWindow (hParent, SW_RESTORE);
+      }
+
       winRestoreModeKeyStates ();
 
       /* Add the keyboard hook if possible */
@@ -668,6 +683,9 @@ winTopLevelWindowProc (HWND hwnd, UINT m
 
       /* Remove our keyboard hook if it is installed */
       winRemoveKeyboardHookLL ();
+      if (!wParam)
+	/* Revert the X focus as well, but only if the Windows focus is going to another thread */
+	DeleteWindowFromAnyEvents(pWin, FALSE);
       return 0;
 
     case WM_SYSDEADCHAR:      
@@ -770,6 +788,10 @@ winTopLevelWindowProc (HWND hwnd, UINT m
 	    if (!pWin || !pWin->overrideRedirect) /* for OOo menus */
 	      winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
 	}
+      /* Prevent the mouse wheel from stalling when another window is minimized */
+      if (HIWORD(wParam) == 0 && LOWORD(wParam) == WA_ACTIVE &&
+	  (HWND)lParam != NULL && (HWND)lParam != (HWND)GetParent(hwnd))
+	SetFocus(hwnd);
       return 0;
 
     case WM_ACTIVATEAPP:
@@ -824,94 +846,51 @@ winTopLevelWindowProc (HWND hwnd, UINT m
       if (!wParam)
 	return 0;
 
-      /* Tell X to map the window */
-      MapWindow (pWin, wClient(pWin));
-
       /* */
       if (!pWin->overrideRedirect)
 	{
-	  DWORD		dwExStyle;
-	  DWORD		dwStyle;
-	  RECT		rcNew;
-	  int		iDx, iDy;
-	      
 	  /* Flag that this window needs to be made active when clicked */
 	  SetProp (hwnd, WIN_NEEDMANAGE_PROP, (HANDLE) 1);
 
-	  /* Get the standard and extended window style information */
-	  dwExStyle = GetWindowLongPtr (hwnd, GWL_EXSTYLE);
-	  dwStyle = GetWindowLongPtr (hwnd, GWL_STYLE);
-
-	  /* */
-	  if (dwExStyle != WS_EX_APPWINDOW)
+	  if (!(GetWindowLongPtr (hwnd, GWL_EXSTYLE) & WS_EX_APPWINDOW))
 	    {
-	      /* Setup a rectangle with the X window position and size */
-	      SetRect (&rcNew,
-		       pDraw->x,
-		       pDraw->y,
-		       pDraw->x + pDraw->width,
-		       pDraw->y + pDraw->height);
-
-#if 0
-	      ErrorF ("winTopLevelWindowProc - (%d, %d)-(%d, %d)\n",
-		      rcNew.left, rcNew.top,
-		      rcNew.right, rcNew.bottom);
-#endif
-
-	      /* */
-	      AdjustWindowRectEx (&rcNew,
-				  WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW,
-				  FALSE,
-				  WS_EX_APPWINDOW);
-
-	      /* Calculate position deltas */
-	      iDx = pDraw->x - rcNew.left;
-	      iDy = pDraw->y - rcNew.top;
-
-	      /* Calculate new rectangle */
-	      rcNew.left += iDx;
-	      rcNew.right += iDx;
-	      rcNew.top += iDy;
-	      rcNew.bottom += iDy;
-
-#if 0
-	      ErrorF ("winTopLevelWindowProc - (%d, %d)-(%d, %d)\n",
-		      rcNew.left, rcNew.top,
-		      rcNew.right, rcNew.bottom);
-#endif
+	      HWND		zstyle = HWND_NOTOPMOST;
 
 	      /* Set the window extended style flags */
 	      SetWindowLongPtr (hwnd, GWL_EXSTYLE, WS_EX_APPWINDOW);
 
+	      /* Set the transient style flags */
+	      if (GetParent(hwnd)) SetWindowLongPtr (hwnd, GWL_STYLE,
+		   WS_POPUP | WS_OVERLAPPED | WS_SYSMENU | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
 	      /* Set the window standard style flags */
-	      SetWindowLongPtr (hwnd, GWL_STYLE,
-				WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW);
-
-	      /* Position the Windows window */
-	      SetWindowPos (hwnd, HWND_TOP,
-			    rcNew.left, rcNew.top,
-			    rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
-			    SWP_NOMOVE | SWP_FRAMECHANGED
-			    | SWP_SHOWWINDOW | SWP_NOACTIVATE);
+	      else SetWindowLongPtr (hwnd, GWL_STYLE,
+		   (WS_POPUP | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS)
+		   & ~WS_CAPTION & ~WS_SIZEBOX);
 
-	      /* Bring the Windows window to the foreground */
+	      winUpdateWindowPosition (hwnd, FALSE, &zstyle);
 	      SetForegroundWindow (hwnd);
 	    }
+	  wmMsg.msg = WM_WM_MAP;
 	}
       else /* It is an overridden window so make it top of Z stack */
 	{
 #if CYGWINDOWING_DEBUG
 	  ErrorF ("overridden window is shown\n");
 #endif
-	  SetWindowPos (hwnd, HWND_TOPMOST, 0, 0, 0, 0,
-			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+	  HWND forHwnd = GetForegroundWindow();
+	  if (forHwnd != NULL)
+	  {
+	    if (GetWindowLongPtr(forHwnd, GWLP_USERDATA) & (LONG_PTR)XMING_SIGNATURE)
+	    {
+	      if (GetWindowLongPtr(forHwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
+		SetWindowPos (hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+	      else
+		SetWindowPos (hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+	    }
+	  }
+	  wmMsg.msg = WM_WM_MAP2;
 	}
 	  
-      /* Setup the Window Manager message */
-      wmMsg.msg = WM_WM_MAP;
-      wmMsg.iWidth = pDraw->width;
-      wmMsg.iHeight = pDraw->height;
-
       /* Tell our Window Manager thread to map the window */
       if (fWMMsgInitialized)
 	winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
@@ -1009,6 +988,7 @@ winTopLevelWindowProc (HWND hwnd, UINT m
 #endif
       /* Adjust the X Window to the moved Windows window */
       winAdjustXWindow (pWin, hwnd);
+      if (wParam == SIZE_MINIMIZED) winReorderWindowsMultiWindow();
       return 0; /* end of WM_SIZE handler */
 
     case WM_MOUSEACTIVATE:
Index: xorg-server-1.5.3/xserver/hw/xwin/winwindow.h
===================================================================
--- xorg-server-1.5.3.orig/xserver/hw/xwin/winwindow.h
+++ xorg-server-1.5.3/xserver/hw/xwin/winwindow.h
@@ -2,6 +2,7 @@
 #define _WINWINDOW_H_
 /*
  *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
+ *Copyright (C) Colin Harrison 2005-2008
  *
  *Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -28,6 +29,7 @@
  *from the XFree86 Project.
  *
  * Authors:	Kensuke Matsuzaki
+ *              Colin Harrison
  */
 
 #ifndef NO
@@ -60,6 +62,8 @@
 #define CYGWINDOWING_DEBUG	NO
 #endif
 
+#define XMING_SIGNATURE		0x12345678L
+
 typedef struct _winPrivScreenRec *winPrivScreenPtr;
 
 
@@ -111,9 +115,24 @@ typedef struct _winWMMessageRec{
 #define		WM_WM_NAME_EVENT	(WM_USER + 9)
 #define		WM_WM_HINTS_EVENT	(WM_USER + 10)
 #define		WM_WM_CHANGE_STATE	(WM_USER + 11)
+#define		WM_WM_MAP2		(WM_USER + 12)
 #define		WM_MANAGE		(WM_USER + 100)
 #define		WM_UNMANAGE		(WM_USER + 102)
 
+#define		MwmHintsDecorations	(1L << 1)
+
+#define		MwmDecorAll		(1l << 0)
+#define		MwmDecorBorder		(1l << 1)
+#define		MwmDecorHandle		(1l << 2)
+#define		MwmDecorTitle		(1l << 3)
+
+/* This structure only contains 3 elements... the Motif 2.0 structure
+contains 5... we only need the first 3... so that is all we will define */
+typedef struct MwmHints {
+  unsigned long		flags, functions, decorations;
+} MwmHints;
+#define		PropMwmHintsElements	3
+
 void
 winSendMessageToWM (void *pWMInfo, winWMMessagePtr msg);
 
