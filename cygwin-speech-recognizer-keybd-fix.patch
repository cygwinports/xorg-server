Cygwin/X: Invent a scan code if we don't have one

Apparently, fake keypresses generated by speech recognizers may not bother
with a scan code, so look up what scan code corresponds to the virtual key
code if this occurs.

Patch by Paul Loewenstein <paul.loewenstein@gmail.com>

--- origsrc/xorg-server-1.5.3/hw/xwin/winkeybd.c	2009-01-17 13:17:33.000000000 -0800
+++ src/xorg-server-1.5.3/hw/xwin/winkeybd.c	2009-01-19 08:21:55.584600000 -0800
@@ -80,6 +80,20 @@
   int		iKeyFixupEx = g_iKeyMap[wParam * WIN_KEYMAP_COLS + 2];
   int		iParamScanCode = LOBYTE (HIWORD (lParam));
 
+/* WM_ key messages faked by Vista speech recognition (WSR) don't have a
+ * scan code.
+ *
+ * Vocola 3 (Rick Mohr's supplement to WSR) uses
+ * System.Windows.Forms.SendKeys.SendWait(), which appears always to give a
+ * scan code of 1
+ */
+  if (iParamScanCode <= 1)
+    {
+      iParamScanCode = MapVirtualKeyEx(wParam,
+				       /*MAPVK_VK_TO_VSC*/0,
+				       GetKeyboardLayout(0));
+    }
+
   /* Branch on special extended, special non-extended, or normal key */
   if ((HIWORD (lParam) & KF_EXTENDED) && iKeyFixupEx)
     *piScanCode = iKeyFixupEx;
--- origsrc/xorg-server-1.5.3/hw/xwin/winkeybd.h	2007-10-23 14:26:52.000000000 -0700
+++ src/xorg-server-1.5.3/hw/xwin/winkeybd.h	2009-01-17 12:46:15.475681500 -0800
@@ -45,6 +45,11 @@
 
 #define		WIN_KEYMAP_COLS		3
 
+/* ASCII column, rows 33 through 40 are for Speech Recognition with
+ * num-lock asserted.
+ * Rows 160 through 165 correspond to software-generated codes, which
+ * may not be associated with the appropriate scan code/extended bit
+ */
 const int
 g_iKeyMap [] = {
   /* count	Windows VK,	ASCII,		ASCII when extended VK */
@@ -81,14 +86,14 @@
   /* 30 */	0,		0,		0,
   /* 31 */	0,		0,		0,
   /* 32 */	0,		0,		0,
-  /* 33 */	VK_PRIOR,	0,		KEY_PgUp,
-  /* 34 */	VK_NEXT,	0,		KEY_PgDown,
-  /* 35 */	VK_END,		0,		KEY_End,
-  /* 36 */	VK_HOME,	0,		KEY_Home,
-  /* 37 */	VK_LEFT,	0,		KEY_Left,
-  /* 38 */	VK_UP,		0,		KEY_Up,
-  /* 39 */	VK_RIGHT,	0,		KEY_Right,
-  /* 40 */	VK_DOWN,	0,		KEY_Down,
+  /* 33 */	VK_PRIOR,	KEY_PgUp,	KEY_PgUp,
+  /* 34 */	VK_NEXT,	KEY_PgDown,	KEY_PgDown,
+  /* 35 */	VK_END,		KEY_End,	KEY_End,
+  /* 36 */	VK_HOME,	KEY_Home,	KEY_Home,
+  /* 37 */	VK_LEFT,	KEY_Left,	KEY_Left,
+  /* 38 */	VK_UP,		KEY_Up,	 	KEY_Up,
+  /* 39 */	VK_RIGHT,	KEY_Right,	KEY_Right,
+  /* 40 */	VK_DOWN,	KEY_Down,	KEY_Down,
   /* 41 */	0,		0,		0,
   /* 42 */	0,		0,		0,
   /* 43 */	0,		0,		0,
@@ -208,12 +213,12 @@
   /* 157 */	0,		0,		0,
   /* 158 */	0,		0,		0,
   /* 159 */	0,		0,		0,
-  /* 160 */	0,		0,		0,
-  /* 161 */	0,		0,		0,
-  /* 162 */	0,		0,		0,
-  /* 163 */	0,		0,		0,
-  /* 164 */	0,		0,		0,
-  /* 165 */	0,		0,		0,
+  /* 160 */	VK_LSHIFT,	KEY_ShiftL,	KEY_ShiftL,
+  /* 161 */	VK_RSHIFT,	KEY_ShiftR,	KEY_ShiftR,
+  /* 162 */	VK_LCONTROL,	KEY_LCtrl,	KEY_LCtrl,
+  /* 163 */	VK_RCONTROL,	KEY_RCtrl,	KEY_RCtrl,
+  /* 164 */	VK_LMENU,	KEY_Alt,	KEY_Alt,
+  /* 165 */	VK_RMENU,	KEY_AltLang,	KEY_AltLang,
   /* 166 */	0,		0,		0,
   /* 167 */	0,		0,		0,
   /* 168 */	0,		0,		0,

